# Teleporter Plugin V0 - Design & Implementation Plan

## Overview
Teleporter is an Obsidian plugin that enables seamless file movement between vaults. V0 will focus on delivering core functionality with a simple, reliable user experience on desktop platforms.

## Goals for V0
1. **Core Feature**: Move the current active file from one vault to another
2. **User Experience**: Simple hotkey-triggered workflow with vault selection
3. **Platform**: Desktop-only support initially (Windows, macOS, Linux)
4. **Reliability**: Ensure safe file operations with proper error handling

## Architecture

### High-Level Design
```
User Trigger (Hotkey)
    ↓
Teleporter Command
    ↓
Vault Selector Modal
    ↓
Destination Folder Selector
    ↓
File Movement Operation
    ↓
Cleanup & Notification
```

### Component Structure

#### 1. Main Plugin Class (`TeleporterPlugin`)
- Extends Obsidian Plugin
- Manages plugin lifecycle
- Registers commands and hotkeys
- Handles settings loading/saving

#### 2. Settings Management (`TeleporterSettings`)
- Interface for plugin settings
- Store configured vaults and their paths
- Default hotkey configuration
- File handling preferences (delete original, copy instead of move, etc.)

#### 3. Vault Manager (`VaultManager`)
- Discovers available vaults
- Validates vault paths
- Caches vault information
- Handles vault configuration CRUD operations

#### 4. File Mover (`FileMover`)
- Core file operation logic
- Handles file reading/writing
- Manages file metadata preservation
- Implements rollback on failure

#### 5. UI Components
- **VaultSelectorModal**: Lists available vaults for selection
- **FolderSelectorModal**: Browse destination vault's folder structure
- **SettingsTab**: Configure vaults and preferences

## Technical Implementation Details

### Data Structures

```typescript
interface TeleporterSettings {
    vaults: VaultConfig[];
    deleteOriginalAfterMove: boolean;
    preserveFileHistory: boolean;
    showConfirmation: boolean;
    defaultHotkey: string;
}

interface VaultConfig {
    id: string;
    name: string;
    path: string;
    isValid: boolean;
    lastAccessed?: number;
}

interface MoveOperation {
    sourceFile: TFile;
    sourceVault: string;
    targetVault: VaultConfig;
    targetPath: string;
    timestamp: number;
    status: 'pending' | 'success' | 'failed';
}
```

### File Movement Strategy

#### Option A: Direct File System Operations (Recommended for V0)
- Use Node.js `fs` module for file operations
- Direct access to vault directories
- Pros: Simple, reliable, full control
- Cons: Desktop-only, requires file system permissions

#### Option B: URI-Based Approach (Future Enhancement)
- Leverage Obsidian URI protocol
- Potentially use Advanced URI plugin
- Pros: Could work on mobile, uses official APIs
- Cons: Complex coordination, limited control, dependency on external plugin

**Decision for V0**: Use Option A for simplicity and reliability

### Implementation Phases

#### Phase 1: Foundation (Week 1)
1. Set up project structure and rename from sample plugin
2. Create basic plugin skeleton with proper naming
3. Implement settings infrastructure
4. Create vault configuration storage

#### Phase 2: Vault Management (Week 1-2)
1. Implement vault discovery mechanism
2. Build vault validation logic
3. Create vault management UI in settings
4. Add manual vault path configuration

#### Phase 3: Core File Operations (Week 2)
1. Implement file reading from source vault
2. Implement file writing to target vault
3. Add metadata preservation
4. Implement error handling and rollback

#### Phase 4: User Interface (Week 3)
1. Create vault selector modal
2. Implement folder browser for destination
3. Add progress indicators
4. Create success/error notifications

#### Phase 5: Polish & Testing (Week 3-4)
1. Add confirmation dialogs
2. Implement undo functionality
3. Add keyboard navigation
4. Comprehensive error handling
5. User testing and bug fixes

## User Workflows

### Primary Workflow: Move Current File
1. User opens file in Obsidian
2. User triggers hotkey (default: Ctrl/Cmd + Shift + M)
3. Vault selector modal appears
4. User selects destination vault
5. Folder selector appears showing destination vault structure
6. User selects target folder
7. File is moved, original is deleted (configurable)
8. Success notification appears

### Settings Configuration Workflow
1. User opens plugin settings
2. User adds vault configurations:
   - Browse to vault location
   - Or manually enter vault path
   - Set vault nickname
3. User configures preferences:
   - Keep/delete original file
   - Show confirmation dialog
   - Set custom hotkey

## Edge Cases & Error Handling

### Critical Scenarios
1. **File Already Exists**: Prompt for rename or overwrite
2. **Vault Unavailable**: Show error, offer to update vault configuration
3. **Permission Denied**: Clear error message with resolution steps
4. **Network Drive**: Warn about potential issues, allow with confirmation
5. **Large Files**: Show progress indicator, allow cancellation
6. **Linked Files**: Detect and warn about broken links

### Error Recovery
- Implement atomic operations where possible
- Keep backup of original file until operation completes
- Provide clear rollback mechanism
- Log all operations for debugging

## Security Considerations
1. Validate all file paths to prevent directory traversal
2. Sanitize file names
3. Check file permissions before operations
4. Don't store sensitive information in settings

## Performance Considerations
1. Lazy load vault information
2. Cache folder structures temporarily
3. Implement debouncing for UI updates
4. Use async operations for file I/O

## Testing Strategy

### Unit Tests
- Vault path validation
- File operation logic
- Settings management
- Error handling paths

### Integration Tests
- Full file movement flow
- Vault discovery
- UI modal interactions

### Manual Testing Checklist
- [ ] Move file between vaults on same drive
- [ ] Move file between different drives
- [ ] Move file with special characters in name
- [ ] Move file to vault on network drive
- [ ] Move file when destination exists
- [ ] Cancel operation mid-flow
- [ ] Test with vaults of different sizes
- [ ] Test hotkey conflicts
- [ ] Test settings persistence

## Dependencies
- Obsidian API (included)
- Node.js fs module (for file operations)
- No external npm packages for V0

## Future Enhancements (Post-V0)
1. Batch file operations
2. Move entire folders
3. Quick vault switching without file movement
4. Integration with Advanced URI plugin
5. Mobile support
6. Sync conflict resolution
7. Move history with undo/redo
8. Template-based file organization
9. Auto-categorization based on file content
10. Cross-vault search before move

## Success Metrics for V0
1. Successfully move files between vaults without data loss
2. Complete operation in < 2 seconds for average file
3. Clear error messages for all failure scenarios
4. Intuitive UI requiring no documentation for basic use
5. Settings persist across plugin restarts

## Development Timeline
- **Week 1**: Foundation and Vault Management
- **Week 2**: Core File Operations
- **Week 3**: User Interface and Polish
- **Week 4**: Testing and Bug Fixes
- **Total**: 4 weeks to V0

## Release Checklist
- [ ] All core features implemented
- [ ] Settings UI complete
- [ ] Error handling comprehensive
- [ ] Manual testing complete
- [ ] Documentation written
- [ ] Plugin manifest updated
- [ ] Version number set to 0.1.0
- [ ] GitHub repository prepared
- [ ] Community plugin submission ready